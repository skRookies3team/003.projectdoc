# [ADR-0002] 사진 데이터 보존을 위한 아카이브 분리 및 서비스 리팩토링

- **상태**: 승인됨 (Accepted) [2025-12-03]
- **결정자**: 김지은
- **관련 문서**: Issue #4, PR #6

## 1. 배경 및 문제 (Context)

현재 다이어리 서비스는 `Diary`와 `DiaryImage`가 강하게 결합(Strong Coupling)되어 있습니다. `CascadeType.ALL`과 `orphanRemoval=true` 설정으로 인해 **다이어리를 삭제하면 사용자가 업로드한 사진 데이터까지 영구적으로 삭제**되는 문제가 발생합니다. 사용자는 일기는 지우더라도 추억이 담긴 원본 사진은 보관함에 남겨두기를 원합니다.

또한, `DiaryService`의 코드 복잡도가 증가함에 따라 다음과 같은 유지보수 문제가 확인되었습니다.

1. **서비스 계층의 비대화**: Entity ↔ DTO 변환 로직이 서비스 메서드 내부에 혼재되어 비즈니스 로직 파악이 어려움.
2. **비효율적인 수정 로직**: `PUT` 방식의 전체 수정만 지원하여, 불필요한 데이터 전송과 의도치 않은 데이터 덮어쓰기(Null Update) 위험이 존재함.

## 2. 결정 사항 (Decision)

우리는 다음과 같은 아키텍처 및 로직 변경을 결정했습니다.

1. **사진 보관함 도메인 분리**:
    - 일기에 종속적인 `DiaryImage`와 별개로, 영구 보관을 위한 **`PhotoArchive` 엔티티**를 신설합니다.
    - 일기 생성 시 두 테이블에 모두 저장하며, 다이어리 삭제 시 `PhotoArchive` 데이터는 보존합니다.
    - 보관함 로직을 전담할 `PhotoArchiveController/Service`를 분리하고 `DiaryService`가 이를 의존하도록 구성합니다.
2. **서비스 계층 리팩토링**:
    - **변환 로직 위임**: DTO 클래스 내부로 `toEntity`, `fromEntity` 메서드를 이동시켜 서비스 계층의 코드를 경량화합니다.
    - **PATCH 메서드 도입**: 다이어리 수정 API를 `PUT`에서 `PATCH`로 변경하고, `Dirty Checking` 시 Null 체크를 통해 부분 수정(Dynamic Update)을 지원합니다.

## 3. 결정 근거 (Decision Drivers)

- **데이터 보존성**: 사용자 경험(UX) 측면에서 데이터 유실 방지는 최우선 과제임.
- **SRP(단일 책임 원칙)**: 일기 관리와 사진 보관의 책임이 다르므로 도메인과 서비스를 분리하는 것이 장기적 유지보수에 유리함.
- **네트워크 효율성**: 부분 수정(PATCH)을 통해 필요한 데이터만 전송하여 대역폭을 절약하고 DB 부하를 줄임.
- **코드 가독성**: 서비스 메서드가 비즈니스 흐름(Flow)만 표현하도록 하여 가독성을 높임.

## 4. 고려했던 대안들 (Considered Options)

### [대안 1: 기존 DiaryImage 활용 (Soft Delete)]

`DiaryImage`에 `deleted` 플래그를 추가하여 삭제 시 숨김 처리만 하는 방식.

### [대안 2: 엔티티 분리 및 이중 저장 (Selected)]

일기용 이미지(`DiaryImage`)와 보관용 이미지(`PhotoArchive`)를 물리적으로 분리하여 저장하는 방식.

### [대안 3: 별도 스토리지 서비스 구축]

사진 관리만을 위한 별도의 마이크로서비스(Storage Service)를 구축하여 연동하는 방식.

## 5. 장단점 분석 (Pros and Cons)

### [대안 2: 엔티티 분리 및 이중 저장] (채택됨)

- **장점**:
    - 일기 삭제 로직(`Cascade`)을 수정하지 않고도 보관함 데이터 보존 가능.
    - 일기와 보관함의 생명주기(Lifecycle)를 완벽하게 분리할 수 있음.
    - 구현 비용이 적고 즉시 적용 가능함.
- **단점**:
    - 데이터 중복 저장(DB 용량 증가) 발생. (단, 이미지 URL 문자열만 중복되므로 용량 부담은 미미함)
    - 일기 생성 시 두 번의 `INSERT`가 발생하여 트랜잭션 시간이 소폭 증가함.

### [대안 1: Soft Delete]

- **장점**: DB 용량을 절약할 수 있음.
- **단점**: 모든 조회 쿼리에 `where deleted = false` 조건을 추가해야 하므로 개발 복잡도 증가. "일기에서는 삭제됐지만 보관함에는 있는" 상태를 표현하기 위해 로직이 복잡해짐.

### [대안 3: 별도 스토리지 서비스]

- **장점**: 가장 이상적인 MSA 구조. 확장성이 좋음.
- **단점**: 현재 프로젝트 규모 대비 오버엔지니어링(Over-engineering). 개발 및 운영 비용 과다.

## 6. 결과 및 영향 (Consequences)

- **긍정적**:
    - 다이어리를 삭제해도 사용자의 소중한 사진은 안전하게 보관됨.
    - 서비스 코드가 간결해져 비즈니스 로직 파악이 쉬워짐.
    - `PhotoArchiveService` 분리로 인해 추후 보관함 전용 기능(앨범, 태그 등) 확장이 용이해짐.
- **부정적**:
    - `DiaryService`가 `PhotoArchiveService`를 의존하게 되어 서비스 간 결합도가 생김. (추후 Event 기반 비동기 처리로 개선 고려 필요)
    - `PATCH` 메서드 사용 시 클라이언트 측에서 명시적으로 변경할 필드만 보내야 하는 규약을 준수해야 함.