# [ADR-0002] 대용량 피드 조회를 위한 Slice 기반 페이징 전략

* **상태**: 승인됨 (Accepted) [2025-12-09]
* **결정자**: Social Service Team
* **관련 이슈**: [Feat#8] 피드 무한 스크롤 구현

## 1. 배경 및 문제 (Context)
우리 서비스는 인스타그램과 유사한 피드형 UI를 제공하며, 사용자는 스크롤을 내리며 끊김 없이 콘텐츠를 소비하는 '무한 스크롤(Infinite Scroll)' 경험을 기대한다.
초기 구현에서는 단순 `List` 반환 방식을 사용했으나, 데이터가 늘어날 경우 메모리 오버플로우 및 응답 지연이 발생할 수 있다.
또한, 일반적인 게시판 페이징(`Page<T>`) 방식은 매 요청마다 전체 데이터 개수를 계산하는 `Count Query`를 실행하므로, 데이터 양이 수백만 건에 도달하면 치명적인 DB 성능 저하를 유발한다.

## 2. 결정 사항 (Decision)
우리는 피드 목록 조회 시 **Spring Data JPA의 `Slice<T>` 인터페이스를 사용**하기로 결정했다.

## 3. 결정 근거 (Decision Drivers)
* **쿼리 성능 최적화**: 무한 스크롤 UI에서는 "전체 페이지 수"나 "전체 게시물 수"가 필요하지 않다. 불필요한 Count 쿼리를 제거하여 DB 부하를 최소화해야 한다.
* **사용자 경험 (UX)**: 모바일 환경에서는 정확한 페이지 번호 이동보다 "더 보기(Next)" 기능이 핵심이다.
* **구현 효율성**: Spring Data JPA가 제공하는 `Slice`는 `limit + 1` 조회 방식을 내부적으로 처리해주어 구현이 간편하다.

## 4. 고려했던 대안들 (Considered Options)
* **[대안 1] JPA Slice 반환 (채택됨)**
    * 요청한 사이즈보다 1개를 더 조회하여 `hasNext` 여부만 판단하는 방식.
* **[대안 2] JPA Page 반환 (Limit-Offset + Count)**
    * 전통적인 페이징 방식. 전체 데이터 개수(`totalElements`)를 반환함.
* **[대안 3] Scroll ID (Cursor) 기반 페이징**
    * 마지막 조회된 ID(`lastId`)보다 작은 데이터를 조회하는 방식. (성능상 가장 좋으나 프론트엔드 연동 복잡도 증가)

## 5. 장단점 분석 (Pros and Cons)

### [JPA Slice 반환] (채택됨)
* **장점**:
    * 전체 개수 조회(Count Query)가 발생하지 않아 데이터가 많아져도 조회 속도가 일정하다.
    * `hasNext()` 값을 통해 클라이언트가 다음 요청 시점을 명확히 알 수 있다.
* **단점**:
    * 전체 게시물 개수를 UI에 표시할 수 없다 (우리 서비스 기획상 불필요).

### [JPA Page 반환]
* **장점**: 전체 페이지 수 등 풍부한 메타데이터 제공.
* **단점**: 데이터 양이 많을수록 Count 쿼리가 Full Scan을 유발하여 매우 느려짐.

## 6. 결과 및 영향 (Consequences)
* **긍정적**: 피드 데이터가 대량으로 쌓여도 조회 성능 저하를 방지할 수 있는 기반이 마련되었다.
* **부정적**: 클라이언트(프론트엔드)는 응답 JSON의 `last: boolean` 값을 확인하여 추가 로딩 여부를 결정하는 로직을 구현해야 한다.